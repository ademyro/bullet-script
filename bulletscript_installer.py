import os
import random

def install():
    print('The installation process has now started.')
    print('Creating directory...')
    os.mkdir('C:\\bscript-cmds')
    print('Done, writing files...')
    with open(f'C:\\bscript-cmds\\fire.bat', 'w', encoding='utf-8-sig') as f, open(f'C:\\bscript-cmds\\bs.py', 'w', encoding='utf-8-sig') as s, open(f'C:\\bscript-cmds\\token_types.py', 'w', encoding='utf-8-sig') as t:
        f.write('@echo off\n\npy "C:\\bscript-cmds\\bs.py" %1')
        f.close()
        s.write("import token_types as tt\nimport random, string, sys, os\n\nclass Error:\n    def __init__(self, title, details):\n        self.title = title\n        self.details = details\n\n    def __repr__(self):\n        return f\'{self.title}: {self.details}\'\n\nclass IllegalCharError(Error):\n    def __init__(self, details):\n        super().__init__(\'Illegal Char\', details)\n\nclass ArithmeticError(Error):\n    def __init__(self, details):\n        super().__init__(\'Arithmetic Exeption\', details)\n\nclass InvalidSyntaxError(Error):\n    def __init__(self, details):\n        super().__init__(\'Invalid Syntax\', details)\n\nclass NotFoundError(Error):\n    def __init__(self, details):\n        super().__init__(\'Not Found\', details)\n\nclass IllegalArgumentError(Error):\n    def __init__(self, details):\n        super().__init__(\'Illegal Argument\', details)\n\nclass RuntimeError(Error):\n    def __init__(self, details):\n        super().__init__(\'Runtime Error\', details)\n\nclass Token:\n    def __init__(self, type_, value=None): # value é opcional, por isso o =None\n        self.type = type_\n        self.value = value\n\n    def matches(self, type_, value):\n        return self.type == type_ and self.value == value\n\n    def __repr__(self):\n        return f\'{self.type}:{self.value}\' if self.value else f\'{self.type}\'\n\nclass Lexer: \n    def __init__(self, code):\n        if code == \'\':\n            fail(InvalidSyntaxError(\n                f\'Empty file.\'\n            ))\n        self.code = code \n        self.pos = 0\n        self.char = self.code[self.pos] # primeiro carátere.\n                            \n    def advance(self):\n        self.pos += 1\n        self.char = self.code[self.pos] if self.pos < len(self.code) else None\n\n    def lex(self):\n        tokens = []\n        while self.char is not None: # self.char != None funciona também\n            if self.char in \' \\t\':\n                self.advance()\n                continue\n        \n            if self.char in tt.NUMBERS: # aquela explicacao de antes\n                tokens.append(self.lex_nums())\n                continue\n\n            if self.char in \'\\\'\"\':\n                tokens.append(self.lex_str())\n                self.advance()\n                continue\n\n            if self.char in tt.CHARACTERS:\n                tokens.append(self.lex_id())\n                continue\n\n            if self.char in \';\\n\':\n                tokens.append(Token(tt.NEWLINE))\n                self.advance()\n                continue\n        \n            match self.char:\n                case \'@\':\n                    while self.char != \'\\n\':\n                        self.advance()\n                case \'+\':\n                    tokens.append(Token(tt.PLUS))\n                case \'-\':\n                    tokens.append(Token(tt.MINUS))\n                case \'*\':\n                    tokens.append(Token(tt.MULTI))\n                case \'/\':\n                    tokens.append(Token(tt.DIVIS))\n                case \'^\':\n                    tokens.append(Token(tt.POW))\n                case \'.\':\n                    tokens.append(Token(tt.DOT))\n                case \'(\':\n                    tokens.append(Token(tt.OPEN_PAREN))\n                case \')\':\n                    tokens.append(Token(tt.CLOSE_PAREN))\n                case \'{\':\n                    tokens.append(Token(tt.OPEN_BRACE))\n                case \'}\':\n                    tokens.append(Token(tt.CLOSE_BRACE))\n                case \'[\':\n                    tokens.append(Token(tt.OPEN_BRACKET))\n                case \']\':\n                    tokens.append(Token(tt.CLOSE_BRACKET))\n                case \',\':\n                    tokens.append(Token(tt.COMMA))\n                case \':\':\n                    tokens.append(Token(tt.COLON))\n                case \'=\':\n                    if self.get_next() == \'=\':\n                        self.advance()\n                        tokens.append(Token(tt.LOG_EQ))\n                        self.advance()\n                        continue\n\n                    tokens.append(Token(tt.ASSIGNMENT))\n                case \'!\':\n                    if self.get_next() != \'=\':\n                        fail(InvalidSyntaxError(\n                            f\"Unknown token: \'!\'. Did you mean \'not\'?\"\n                        ))\n\n                    self.advance()\n                    tokens.append(Token(tt.LOG_NEQ))\n                case \'>\':\n                    if self.get_next() == \'=\':\n                        self.advance()\n                        tokens.append(Token(tt.LOG_GTE))\n                        self.advance()\n                        continue\n\n                    tokens.append(Token(tt.LOG_GT))\n                case \'<\':\n                    if self.get_next() == \'=\':\n                        self.advance()\n                        tokens.append(Token(tt.LOG_LTE))\n                        self.advance()\n                        continue\n\n                    tokens.append(Token(tt.LOG_LT))\n                case \' \':\n                    self.advance()\n                    continue\n                case None:\n                    break\n                case _:\n                    fail(IllegalCharError(f\"\'{self.char}\'\"))\n            self.advance()\n\n        tokens.append(Token(tt.EOF))\n        return tokens\n        \n    def lex_nums(self):\n        num_str = \'\'\n        dot = False # ver se tem um ponto. se tiver, o token sera um float.\n        while str(self.char) in tt.NUMBERS + \'.\' and self.char is not None:\n            num_str += self.char \n            if self.char == \'.\': \n                if dot: # se ja tiver um ponto, quer dizer que o numero e invalido e ele so vai quitar do loop\n                    break\n        \n                dot = True\n            self.advance()\n        \n        try:\n            return Token(tt.INT, int(num_str)) if not dot else Token(tt.FLOAT, float(num_str))\n        except ValueError: # se, mesmo assim, tiver um erro na conversao\n            fail(ArithmeticError(\"Float definition with more than one dot.\"))\n\n    def lex_str(self):\n        str_str = \'\'\n        self.advance()\n        while str(self.char) not in \"\'\\\"\":\n            if self.char == None:\n                break\n\n            str_str += str(self.char)\n            self.advance()\n\n        return Token(tt.STRING, str_str)\n\n    def lex_id(self):\n        id_str = \'\'\n        while self.char is not None and str(self.char) in tt.CHARACTERS:\n            id_str += self.char\n            self.advance()\n\n        match id_str:\n            case \'or\':\n                return Token(tt.LOG_OR)\n            case \'and\':\n                return Token(tt.LOG_AND)\n            case \'not\':\n                return Token(tt.LOG_NOT)\n            case \'in\':\n                return Token(tt.LOG_IN)\n\n        return Token(tt.IDENTIFIER, id_str) if not id_str in tt.KEYWORDS else Token(tt.KEYWORD, id_str)\n\n    def get_next(self):\n        return self.code[self.pos + 1] if self.pos + 1 < len(self.code) else fail(InvalidSyntaxError(\'Reached end of file while lexing.\'))\n\n# Nodes .\n\nclass ProgramNode:\n    def __init__(self, statements):\n        self.statements = statements\n\n    def __repr__(self):\n        return f\'program: \\n{self.statements}\'\n\nclass StringNode:\n    def __init__(self, tok):\n        self.str = tok\n        \n    def __repr__(self):\n        return f\'string: {self.str}\'\n\nclass NumberNode: # para numeros\n    def __init__(self, num_tok):\n        self.tok = num_tok\n    \n    def __repr__(self):\n        return f\'{self.tok}\'\n\nclass BooleanNode:\n    def __init__(self, value):\n        self.value = value \n\n    def __repr__(self):\n        return f\'{self.value}\'\n\nclass ReturnNode:\n    def __init__(self, return_value=None):\n        self.value = return_value\n\n    def __repr__(self):\n        return f\'return: {self.value}\' if self.value else f\'return\'\n\nclass BreakNode:\n    def __repr__(self):\n        return \'break\'\n\nclass ContinueNode:\n    def __repr__(self):\n        return \'continue\'\n\nclass ListNode:\n    def __init__(self, elements):\n        self.elements = elements\n\n    def __repr__(self):\n        return f\'{self.elements}\'\n\nclass VarAssignNode:\n    def __init__(self, identifier, value=None):\n        self.identifier = identifier\n        self.value = value\n\n    def __repr__(self):\n        return f\'assign {self.identifier} = {self.value}\' if self.value else f\'declare {self.identifier}\'\n\nclass VarAccessNode:\n    def __init__(self, identifier):\n        self.identifier = identifier\n\n    def __repr__(self):\n        return f\'access {self.identifier}\'\n\nclass BinOpNode: # para operacoes binarias. caso nao sabe o que eh: 1 + 1 eh uma operacao binaria\n    def __init__(self, left_node, op_tok, right_node):\n        self.left = left_node\n        self.op = op_tok\n        self.right = right_node\n\n    def __repr__(self):\n        return f\'({self.left} {self.op} {self.right})\'\n\nclass UnaryOpNode: # para numeros assim o: -1\n    def __init__(self, op_tok, comp):\n        self.op = op_tok\n        self.comp = comp\n    \n    def __repr__(self):\n        return f\'({self.op} {self.comp})\'\n\nclass IfNode:\n    def __init__(self, condition, statements, else_statements=None):\n        self.condition = condition\n        self.statements = statements\n        self.else_statements = else_statements\n\n    def __repr__(self):\n       return  f\'if: {self.condition} \\ndo {self.statements} \\nelse {self.else_statements}\' if self.else_statements else f\'if: {self.condition}\\ndo {self.statements}\'\n\nclass WhileNode:\n    def __init__(self, condition, statements):\n        self.condition = condition\n        self.statements = statements\n\n    def __repr__(self):\n        return f\'execute {self.statements}\\nwhile {self.condition}\'\n\nclass ForNode:\n    def __init__(self, var_identifier, list_, statements):\n        self.id = var_identifier\n        self.list = list_\n        self.statements = statements\n\n    def __repr__(self):\n        return f\'for each {self.id} in {self.list}\\ndo {self.statements}\'\n\nclass FuncDefNode:\n    def __init__(self, identifier, args_list, statements):\n        self.id = identifier\n        self.args_list = args_list\n        self.statements = statements\n\n    def __repr__(self):\n        return f\'function {self.id}\\n(args: {self.args_list})\\nexecute: {self.statements}\\n\'\n\nclass FuncCallNode:\n    def __init__(self, identifier, args_list):\n        self.id = identifier\n        self.args_list = args_list\n\n    def __repr__(self):\n        return f\'call {self.id}\\n(args: {self.args_list})\\n\'\n\nclass SwitchNode:\n    def __init__(self, identifier, values, statements, default_case=None):\n        self.id = identifier\n        self.vals = values\n        self.statements = statements\n        self.default = default_case\n\nclass ElementAccessNode:\n    def __init__(self, identifier, idx):\n        self.id = identifier\n        self.idx = idx\n\n    def __repr__(self):\n        return f\'get element at {self.idx} from {self.id}\'\n\nclass ElementAssignNode:\n    def __init__(self, identifier, idx, value):\n        self.id = identifier\n        self.idx = idx\n        self.value = value\n\n    def __repr__(self):\n        return f\'edit element at {self.idx} from {self.id} with value {self.value}\'\n\nclass ImportNode:\n    def __init__(self, module_id):\n        self.id = module_id\n\n    def __repr__(self):\n        return f\'imports {self.id}\'\n\nclass Parser:\n    def __init__(self, tokens):\n        self.tokens = tokens\n        self.pos = 0\n        self.current_tok = self.tokens[self.pos]\n        self.line = 1\n    \n    def before(self):\n        return self.tokens[self.pos - 1]\n\n    def advance(self):\n        self.pos += 1\n        self.current_tok = self.tokens[self.pos] if self.pos < len(self.tokens) else Token(tt.EOF)\n\n    def parse(self): # vai fazer a arvore dos nossos tokens\n        return ProgramNode(self.parse_statements())\n\n    def parse_statements(self):\n        statements = []\n        while self.current_tok.type != tt.EOF:\n            if self.current_tok.type == tt.NEWLINE:\n                self.line += 1\n                self.advance()\n                continue\n        \n            statements.append(self.expr())\n            if self.current_tok.type == tt.EOF:\n                break # because after self.expr we may encounter an EOF before the next iteration\n\n            if self.current_tok.type != tt.NEWLINE:\n                if self.before().type == tt.NEWLINE:\n                    continue\n                fail(InvalidSyntaxError(\n                    f\'Expected a new line. {self.current_tok}\'\n                ))\n            \n            self.advance()\n\n        return statements\n\n    def parse_inner_statements(self):\n        statements = []\n        while self.current_tok.type != tt.CLOSE_BRACE:\n            if self.current_tok.type == tt.NEWLINE:\n                self.line += 1\n                self.advance()\n                continue\n        \n            statements.append(self.expr())\n            if self.current_tok.type == tt.EOF:\n                fail(InvalidSyntaxError(\n                    f\'Reached end of file while parsing: most likely means that there is an unclosed pair of curly-braces.\'\n                ))\n\n            if self.current_tok.type == tt.CLOSE_BRACE:\n                return statements\n\n            if self.current_tok.type != tt.NEWLINE:\n                if self.before().type == tt.NEWLINE:\n                    continue\n                fail(InvalidSyntaxError(\n                    f\'Expected a new line.\'\n                ))\n            \n            self.advance()\n\n        return statements\n\n    def atom(self): # fator: ele faz os numeros e tudo\n        tok = self.current_tok\n\n        if tok.type in (tt.INT, tt.FLOAT):\n            self.advance()\n            return NumberNode(tok)\n\n        if tok.type == tt.STRING:\n            self.advance()\n            return StringNode(tok)\n\n        if tok.type in tt.IDENTIFIER:\n            self.advance()\n            if self.current_tok.type == tt.ASSIGNMENT:\n                self.advance()\n                expr = self.expr()\n                return VarAssignNode(tok.value, expr)\n            \n            if self.current_tok.type == tt.OPEN_BRACKET:\n                self.advance()\n                idx = self.expr()\n                if self.current_tok.type != tt.CLOSE_BRACKET:\n                    fail(InvalidSyntaxError(\n                        f\'Unclosed brackets.\\nLine {self.line}.\'\n                    ))\n\n                self.advance()\n                if self.current_tok.type == tt.ASSIGNMENT:\n                    self.advance()\n                    expr = self.expr()\n                    return ElementAssignNode(VarAccessNode(tok.value), idx, expr)\n\n                return ElementAccessNode(VarAccessNode(tok.value), idx)\n            \n            if self.current_tok.type == tt.OPEN_PAREN:\n                args_list = []\n                self.advance()\n                if self.current_tok.type == tt.CLOSE_PAREN:\n                    self.advance()\n                    return FuncCallNode(tok.value, args_list)\n\n                while self.current_tok.type != tt.CLOSE_PAREN:\n                    self.skip_newlines()\n                    args_list.append(self.expr())\n                    if self.current_tok.type == tt.CLOSE_PAREN:\n                        break # double precaution\n\n                    if self.current_tok.type != tt.COMMA:\n                        fail(InvalidSyntaxError(\n                            f\"\')\' or \',\' were expected, got \'{self.current_tok}\'.\"\n                        ))\n\n                    self.advance()\n\n                self.advance()\n                return FuncCallNode(tok.value, args_list)\n\n            return VarAccessNode(tok.value)\n\n        if tok.type == tt.OPEN_PAREN:\n            self.advance()\n            expr = self.expr()\n            if self.current_tok.type != tt.CLOSE_PAREN:\n                fail(InvalidSyntaxError(\n                    f\'Never closed parens.\'\n                ))\n\n            self.advance()\n            return expr\n\n        fail(InvalidSyntaxError(\n            f\'Unexpected token: {self.current_tok}.\'\n        ))\n\n    def power(self):\n        return self.bin_op(self.atom, (tt.POW, ), self.factor)\n\n    def factor(self):\n        tok = self.current_tok\n        if tok.type in (tt.PLUS, tt.MINUS, tt.LOG_NOT):\n            self.advance()\n            factor = self.factor()\n            return UnaryOpNode(tok, factor)\n\n        return self.power()\n\n    def term(self):\n        return self.bin_op(self.factor, (tt.DIVIS, tt.MULTI, tt.DOT))\n\n    def arith_expr(self):\n        return self.bin_op(self.term, (tt.PLUS, tt.MINUS))\n\n    def comp_expr(self):\n        if self.current_tok.type == tt.LOG_NOT:\n            op_tok = self.current_tok\n            self.advance()\n            return UnaryOpNode(op_tok, self.comp_expr())\n\n        return self.bin_op(self.arith_expr, (tt.LOG_EQ, tt.LOG_NEQ, tt.LOG_LT, tt.LOG_LTE, tt.LOG_GT, tt.LOG_GTE, tt.LOG_IN))\n\n    def expr(self):\n        if self.current_tok.type == tt.KEYWORD:\n            match self.current_tok.value:\n                case \'if\':\n                    return self.parse_if_statement()\n                case \'while\':\n                    return self.parse_while_statement()\n                case \'for\':\n                    return self.parse_for_statement()\n                case \'fn\':\n                    return self.parse_function_definition()\n                case \'return\':\n                    self.advance()\n                    return_value = self.expr()\n                    return ReturnNode(return_value)\n                case \'break\':\n                    self.advance()\n                    return BreakNode()\n                case \'continue\':\n                    self.advance()\n                    return ContinueNode()\n                case \'load\':\n                    self.advance()\n                    module = self.current_tok\n                    self.advance()\n                    return ImportNode(module.value)\n        \n        if self.current_tok.type == tt.OPEN_BRACKET:\n            return self.parse_list_definition()\n\n        return self.bin_op(self.comp_expr, (tt.LOG_AND, tt.LOG_OR))\n\n    def parse_function_definition(self):\n        self.advance()\n        if self.current_tok.type != tt.IDENTIFIER:\n            fail(InvalidSyntaxError(\n                f\"An identifier was expected, got \'{self.current_tok}\'.\"\n            ))\n\n        identifier = self.current_tok.value\n        self.advance()\n        if self.current_tok.type != tt.OPEN_PAREN:\n            fail(InvalidSyntaxError(\n                f\"\'(\' was expected, got \'{self.current_tok}\'.\"\n            ))\n\n        self.advance()\n        args_list = []\n        if self.current_tok.type != tt.CLOSE_PAREN and self.current_tok.type == tt.IDENTIFIER:\n            while self.current_tok.type != tt.CLOSE_PAREN:\n                self.skip_newlines()\n                args_list.append(self.expr())\n                if self.current_tok.type == tt.CLOSE_PAREN:\n                    break # double precaution\n\n                if self.current_tok.type != tt.COMMA:\n                    fail(InvalidSyntaxError(\n                        f\"\')\' or \',\' were expected, got \'{self.current_tok}\'.\"\n                    ))\n\n                self.advance()\n        \n        self.advance()\n        if self.current_tok.type == tt.COMMA:\n            self.advance()\n            return FuncDefNode(identifier, args_list, [self.expr()])\n        \n        self.skip_newlines()\n        if self.current_tok.type != tt.OPEN_BRACE:\n            fail(InvalidSyntaxError(\n                \"\'{\' was expected, got \'\" + str(self.current_tok) + \'\\\'.\'\n            ))\n\n        self.advance()\n        self.skip_newlines()\n        statements = self.parse_inner_statements()\n        self.skip_newlines()\n        self.advance()\n        return FuncDefNode(identifier, args_list, statements)\n\n    def parse_for_statement(self):\n        self.advance()\n        if self.current_tok.type != tt.IDENTIFIER:\n            fail(InvalidSyntaxError(\n                f\"An identifier was expected, got \'{self.current_tok}\'.\"\n            ))\n\n        identifier = self.current_tok.value\n        self.advance()\n        if self.current_tok.type != tt.LOG_IN:\n            fail(InvalidSyntaxError(\n                f\"\'in\' was expected, got \'{self.current_tok}\'.\"\n            ))\n\n        self.advance()\n        list_ = [self.expr()]\n        if self.current_tok.type == tt.COMMA:\n            self.advance()\n            return ForNode(identifier, ListNode(list_), [self.expr()])\n        \n        self.skip_newlines()\n        if self.current_tok.type != tt.OPEN_BRACE:\n            fail(InvalidSyntaxError(\n                \"\'{\' or \',\' were expected, got \'\" + str(self.current_tok) + \"\'\\nLine \" + str(self.line) + \".\"\n            ))\n\n        self.skip_newlines()\n        self.advance()\n        statements = self.parse_inner_statements()\n        self.advance()\n        self.skip_newlines()\n        return ForNode(identifier, ListNode(list_), statements)\n\n    def parse_list_definition(self):\n        elements = []\n        self.skip_newlines()\n        self.advance()\n        if self.current_tok.type == tt.CLOSE_BRACKET:\n            self.advance()\n            return ListNode(elements)\n\n        while self.current_tok.type != tt.CLOSE_BRACKET:\n            self.skip_newlines()\n            elements.append(self.expr())\n            if self.current_tok.type == tt.CLOSE_BRACKET:\n                self.advance()\n                break # double precaution\n\n            if self.current_tok.type != tt.COMMA:\n                fail(InvalidSyntaxError(\n                    f\"\']\' or \',\' were expected, got \'{self.current_tok}\'.\"\n                ))\n            self.advance()\n        \n        return ListNode(elements)\n\n    def parse_while_statement(self):\n        self.advance()\n        condition = self.expr()\n        if self.current_tok.type == tt.COMMA:\n            self.advance()\n            return WhileNode(condition, [self.expr()])\n\n        self.skip_newlines()\n        if self.current_tok.type != tt.OPEN_BRACE:\n            fail(InvalidSyntaxError(\n                \"\'{\' or \',\' were expected, got \" + str(self.current_tok)\n            ))\n\n        self.skip_newlines()\n        self.advance()\n        statements = self.parse_inner_statements()\n        self.advance()\n        self.skip_newlines()\n        return WhileNode(condition, statements)\n\n    def parse_if_statement(self):\n        self.advance()\n        condition = self.expr()\n        if self.current_tok.type == tt.COMMA:\n            self.advance()\n            statements = [self.expr()]\n            if self.current_tok.matches(tt.KEYWORD, \'else\'):\n                self.skip_newlines()\n                else_statements = self.parse_else_statement()\n                return IfNode(condition, statements, else_statements)\n\n            return IfNode(condition, statements)\n        \n        self.skip_newlines()\n        if self.current_tok.type != tt.OPEN_BRACE:\n            fail(InvalidSyntaxError(\n                \"\'{\' or \',\' were expected, got \" + str(self.current_tok)\n            ))\n        \n        self.skip_newlines()\n        self.advance()\n        statements = self.parse_inner_statements()\n        self.advance()\n        self.skip_newlines()\n        if self.current_tok.matches(tt.KEYWORD, \'else\'):\n            self.skip_newlines()\n            else_statements = self.parse_else_statement()\n            return IfNode(condition, statements, else_statements)\n        \n        return IfNode(condition, statements)\n\n    def parse_else_statement(self):\n        self.advance()\n        self.skip_newlines()\n        if self.current_tok.type != tt.OPEN_BRACE:\n            return [self.expr()]\n\n        self.skip_newlines()\n        self.advance()\n        statements = self.parse_inner_statements()\n        self.skip_newlines()\n        self.advance()\n        return statements\n\n    def skip_newlines(self):\n        while self.current_tok.type == tt.NEWLINE:\n            self.line += 1\n            self.advance()\n\n    def bin_op(self, left_func, ops, right_func=None):\n        if right_func == None:\n            right_func = left_func\n\n        left = left_func()\n        while self.current_tok.type in ops:\n            op_tok = self.current_tok\n            self.advance()\n            right = right_func()\n            left = BinOpNode(left, op_tok, right)\n\n        return left\n\nclass Variable:\n    def __init__(self, identifier, val=None):\n        self.id = identifier\n        self.value = val\n\n    def assign(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return str(self.value)\n\nclass VariableScope:\n    def __init__(self, id_):\n        self.id = id_\n        self.symbols = []\n        self.children = []\n\n    def exists(self, identifier):\n        for v in self.symbols:\n            if v.id == identifier:\n                return True\n\n        if self.children:\n            for c in self.children:\n                for v in c.symbols:\n                    if v.id == identifier:\n                        return True\n\n        return False\n\n    def access(self, identifier):\n        for v in self.symbols:\n            if v.id == identifier:\n                return v\n\n        if self.children:\n            for c in self.children:\n                for v in c.symbols:\n                    if v.id == identifier:\n                        return v\n\n        fail(NotFoundError(\n            f\'{identifier} does not exist.\'\n        ))\n\n    def set(self, var):\n        self.symbols.append(var)\n\n    def set_child(self, scope):\n        self.children.append(scope)\n\n    def get_child(self, scope):\n        for c in self.children:\n            if c.id == scope:\n                return c\n\n    def destroy_child(self, scope):\n        self.children.remove(scope)\n\n    def __repr__(self):\n        return self.id\n\nclass Value:\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def plus(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} + {other.name}\'\n        ))\n\n    def minus(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} - {other.name}\'\n        ))\n    \n    def multi(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} * {other.name}\'\n        ))\n\n    def divis(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} / {other.name}\'\n        ))\n\n    def power(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} ^ {other.name}\'\n        ))\n\n    def compare_equals(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} == {other.name}\'\n        ))\n\n    def compare_nequals(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} != {other.name}\'\n        ))\n\n    def compare_greater(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} > {other.name}\'\n        ))\n\n    def compare_greater_eq(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} >= {other.name}\'\n        ))\n\n    def compare_smaller(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} < {other.name}\'\n        ))\n\n    def compare_smaller_eq(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} <= {other.name}\'\n        ))\n\n    def is_true(self):\n        fail(ArithmeticError(\n            f\'{self.name} cannot be referred to a boolean type.\'\n        ))\n\n    def negate(self):\n        fail(ArithmeticError(\n            f\'{self.name} cannot be referred to a boolean type.\'\n        ))\n\n    def and_(self, other):\n        fail(ArithmeticError(\n            f\'{self.name} cannot be referred to a boolean type.\'\n        ))\n\n    def or_(self, other):\n        fail(ArithmeticError(\n            f\'{self.name} cannot be referred to a boolean type.\'\n        ))\n\n    def check_contains(self, other):\n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} in {other.name}\'\n        ))\n\nclass Number(Value):\n    def __init__(self, value):\n        super().__init__(\'<number>\', value)\n\n    def plus(self, other):\n        return Number(self.value + other.value)\n\n    def minus(self, other):\n        return Number(self.value - other.value)\n    \n    def multi(self, other):\n        return Number(self.value * other.value)\n\n    def divis(self, other):\n        return Number(self.value / other.value)\n\n    def power(self, other):\n        return Number(self.value ** other.value)\n\n    def compare_equals(self, other):\n        return Boolean(self.value == other.value)\n\n    def compare_nequals(self, other):\n        return Boolean(self.value != other.value)\n\n    def compare_greater(self, other):\n        return Boolean(self.value > other.value)\n\n    def compare_greater_eq(self, other):\n        return Boolean(self.value >= other.value)\n\n    def compare_smaller(self, other):\n        return Boolean(self.value < other.value)\n\n    def compare_smaller_eq(self, other):\n        return Boolean(self.value <= other.value)\n\n    def is_true(self):\n        return Boolean(self.value > -1)\n\n    def negate(self):\n        return Boolean(not self.value)\n\n    def and_(self, other):\n        return Boolean(self.value and other.value)\n\n    def or_(self, other):\n        return Boolean(self.value or other.value)\n\n    def dot_string(self, argv):\n        return String(str(self.value))\n\n    def no_dot_method(self, argv):\n        fail(RuntimeError(\n            f\'<number> has no attribute.\'\n        ))\n\n    def check_contains(self, other):\n        if not (isinstance(other, String) or isinstance(other, List)):\n            fail(ArithmeticError(\n                f\'Illegal operation: {self.name} in {other.name}\'\n            ))\n        \n        return Boolean(self.value in other.value)\n\n    def __repr__(self):\n        return str(self.value)\n\nclass Boolean(Value):\n    def __init__(self, bool_value):\n        super().__init__(\'<boolean>\', bool_value)\n\n    def compare_nequals(self, other):\n        return Boolean(self.value != other.value)\n\n    def compare_equals(self, other):\n        return Boolean(self.value == other.value)\n        \n    def is_true(self):\n        return self.value\n\n    def negate(self):\n        return Boolean(not self.value)\n\n    def and_(self, other):\n        return Boolean(self.value and other.value)\n\n    def or_(self, other):\n        return Boolean(self.value or other.value)\n\n    def check_contains(self, other):\n        if not (isinstance(other, String) or isinstance(other, List)):\n            fail(ArithmeticError(\n                f\'Illegal operation: {self.name} in {other.name}\'\n            ))\n        \n        return Boolean(self.value in other.value)\n\n    def __repr__(self):\n        match self.value:\n            case True:\n                return \'true\'\n            case False:\n                return \'false\'\n            case None:\n                return \'null\'\n\nclass List(Value):\n    def __init__(self, elements):\n        super().__init__(\'<list>\', elements)\n        self.len = len(elements)\n\n    def dot_string(self, argv):\n        return String(str(self.value))\n\n    def dot_append(self, argv):\n        if len(argv) > 1:\n            fail(RuntimeError(\n                f\'One argument expected in call \\\'append\\\'\'\n            ))\n\n        value = Interpreter().visit(argv[0])\n        self.value.append(value)\n        return self\n\n    def dot_len(self, argv):\n        return Number(len(self.value))\n\n    def no_dot_method(self, argv):\n        fail(NotFoundError(\n            f\'{self.name} has no attribute.\'\n        ))\n\n    def check_contains(self):\n        if not (isinstance(other, String) or isinstance(other, List)):\n            fail(ArithmeticError(\n                f\'Illegal operation: {self.name} in {other.name}\'\n            ))\n        \n        return Boolean(self.value in other.value)\n    \n    def __repr__(self):\n        return f\'{self.value}\'\n\nclass String(Value):\n    def __init__(self, value):\n        super().__init__(\'<str>\', value)\n\n    def plus(self, other):\n        if isinstance(other, String):\n            return String(self.value + other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} + {other.name}\'\n        ))\n\n    def minus(self, other):\n        if isinstance(other, String):\n            return String(self.value - other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} - {other.name}\'\n        ))\n    \n    def multi(self, other):\n        if isinstance(other, String):\n            return String(self.value * other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} * {other.name}\'\n        ))\n\n    def divis(self, other):\n        if isinstance(other, String):\n            return String(self.value / other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} / {other.name}\'\n        ))\n\n    def power(self, other):\n        if isinstance(other, String):\n            return String(self.value ** other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} ^ {other.name}\'\n        ))\n\n    def compare_equals(self, other):\n        if isinstance(other, String):\n            return Boolean(self.value == other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} == {other.name}\'\n        ))\n\n    def compare_nequals(self, other):\n        if isinstance(other, String):\n            return Boolean(self.value != other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} != {other.name}\'\n        ))\n\n    def compare_greater(self, other):\n        if isinstance(other, String):\n            return Boolean(self.value > other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} > {other.name}\'\n        ))\n\n    def compare_greater_eq(self, other):\n        if isinstance(other, String):\n            return Boolean(self.value >= other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} >= {other.name}\'\n        ))\n\n    def compare_smaller(self, other):\n        if isinstance(other, String):\n            return Boolean(self.value < other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} < {other.name}\'\n        ))\n\n    def compare_smaller_eq(self, other):\n        if isinstance(other, String):\n            return Boolean(self.value <= other.value)\n        \n        fail(ArithmeticError(\n            f\'Illegal operation: {self.name} <= {other.name}\'\n        ))\n\n    def and_(self, other):\n        return Boolean(self.value and other.value)\n\n    def or_(self, other):\n        return Boolean(self.value or other.value)\n\n    def dot_num(self, argv):\n        try:\n            return Number(int(self.value))\n        except ValueError:\n            fail(ArithmeticError(\n                f\'Cannot convert {self.value} to <number>.\'\n            ))\n\n    def dot_len(self, argv):\n        return Number(len(self.value))\n\n    def dot_chararray(self, argv):\n        return List([String(c) for c in self.value])\n\n    def no_dot_method(self):\n        fail(RuntimeError(\n            f\'<number> has no attribute.\'\n        ))\n\n    def check_contains(self, other):\n        if not (isinstance(other, String) or isinstance(other, List)):\n            fail(ArithmeticError(\n                f\'Illegal operation: {self.name} in {other.name}\'\n            ))\n        \n        return Boolean(self.value in other.value)\n\n    def __repr__(self):\n        return f\'{self.value}\'\n\nclass Function(Value):\n    def __init__(self, identifier, statements, args_list):\n        super().__init__(\'<function>\', identifier)\n        self.id = identifier\n        self.statements = statements\n        self.args = args_list\n\n    def __repr__(self):\n        return f\'<function {self.id}>\'\n\nclass ExitFunction(Exception):\n    def __init__(self, value):\n        self.value = value\n\nclass ContinueLoop(Exception):\n    pass\n\nclass BreakLoop(Exception):\n    pass\n\nclass Interpreter:\n    def visit(self, node):\n        vst_method = getattr(self, f\'visit_{type(node).__name__}\', self.undefined_node)\n        return vst_method(node)\n\n    def undefined_node(self, node):\n        raise Exception(f\'No visit method named {type(node).__name__}\')\n\n    def visit_ProgramNode(self, node):\n        interpreted_statements = []\n        for s in node.statements:\n            interpreted_statements.append(self.visit(s))\n\n        return interpreted_statements\n    \n    def visit_ImportNode(self, node):\n        run(node.id + \'.bs\')\n\n    def visit_NumberNode(self, node):\n        return Number(node.tok.value)\n\n    def visit_StringNode(self, node):\n        return String(node.str.value)\n\n    def visit_BooleanNode(self, node):\n        return Boolean(node.value)\n\n    def visit_ListNode(self, node):\n        new_elements = []\n        for e in node.elements:\n            new_elements.append(self.visit(e))\n\n        return List(new_elements)\n\n    def visit_ReturnNode(self, node):\n        raise ExitFunction(self.visit(node.value))\n\n    def visit_ContinueNode(self, node):\n        raise ContinueLoop()\n\n    def visit_BreakNode(self, node):\n        raise BreakLoop()\n\n    def visit_FuncDefNode(self, node):\n        if scope.exists(node.id):\n            fail(RuntimeError(\n                f\'Function {node.id} already exists.\'\n            ))\n\n        if node.id in tt.PRIMITIVE_FUNCTIONS:\n            fail(RuntimeError(\n                f\'Cannot override primitive function {node.id}.\'\n            ))\n\n        func = Function(node.id, node.statements, node.args_list)\n        scope.set(func)\n        return func\n\n    def visit_FuncCallNode(self, node):\n        if node.id in tt.PRIMITIVE_FUNCTIONS:\n            method = getattr(self, f\'primitive_{node.id}\')\n            return method(node.args_list)\n\n        fn = scope.access(node.id)\n        if not isinstance(fn, Function):\n            fail(InvalidSyntaxError(\n                f\'{fn.id} is not callable.\'\n            ))\n\n        names = [a.identifier for a in fn.args]\n        if len(fn.args) > len(node.args_list):\n            fail(RuntimeError(\n                f\'Too few args passed into {fn.id}.\'\n            ))\n\n        if len(fn.args) < len(node.args_list):\n            fail(RuntimeError(\n                f\'Too many args passed into {fn.id}.\'\n            ))\n\n        func_scope = VariableScope(node.id + \'\'.join(random.choices(string.ascii_uppercase + string.digits, k=5)))\n        for i in range(len(fn.args)):\n            func_scope.set(Variable(names[i], self.visit(node.args_list[i])))\n\n        scope.set_child(func_scope)\n        interpreted_statements = []\n        try:\n            for s in fn.statements:\n                interpreted_statements.append(self.visit(s))\n        except ExitFunction as e:\n            scope.destroy_child(func_scope)\n            return e.value\n\n        scope.destroy_child(func_scope)\n\n        return interpreted_statements\n\n    def visit_BinOpNode(self, node):\n        left = self.visit(node.left)\n        right = self.visit(node.right) if node.op.type != tt.DOT else node.right\n\n        match node.op.type:\n            case tt.PLUS:\n                return left.plus(right)\n            case tt.MINUS:\n                return left.minus(right)\n            case tt.MULTI:\n                return left.multi(right)\n            case tt.DIVIS:\n                return left.divis(right)\n            case tt.POW:\n                return left.power(right)\n            case tt.LOG_AND:\n                return left.and_(right)\n            case tt.LOG_OR:\n                return left.or_(right)\n            case tt.LOG_EQ:\n                return left.compare_equals(right)\n            case tt.LOG_NEQ:\n                return left.compare_nequals(right)\n            case tt.LOG_GT:\n                return left.compare_greater(right)\n            case tt.LOG_GTE:\n                return left.compare_greater_eq(right)\n            case tt.LOG_LT:\n                return left.compare_smaller(right)\n            case tt.LOG_LTE:\n                return left.compare_smaller_eq(right)\n            case tt.LOG_IN:\n                return left.check_contains(right)\n            case tt.DOT:\n                if isinstance(right, FuncCallNode):\n                    method = getattr(left, f\'dot_{right.id}\', left.no_dot_method)\n                    return method(right.args_list)\n\n    def visit_IfNode(self, node):\n        executes = self.visit(node.condition)\n        if executes.is_true():\n            interpreted_statements = []\n            for s in node.statements:\n                interpreted_statements.append(self.visit(s))\n\n            return interpreted_statements\n        \n        if node.else_statements:\n            interpreted_statements = []\n            for s in node.else_statements:\n                interpreted_statements.append(self.visit(s))\n            \n            return interpreted_statements\n\n    def visit_WhileNode(self, node):\n        continues = self.visit(node.condition)\n        interpreted_statements = []\n        while True:\n            continues = self.visit(node.condition) # updating continues each iteration.\n            if not continues.is_true():\n                break\n\n            try:\n                for s in node.statements:\n                    interpreted_statements.append(self.visit(s))\n            except ContinueLoop as e:\n                continue\n            except BreakLoop as e:\n                break\n\n        return interpreted_statements\n\n    def visit_ForNode(self, node):\n        results = []\n        list_ = self.visit(node.list)\n        if len(list_.value) == 1 and isinstance(list_.value[0], List):\n            list_ = list_.value[0]\n\n        idx = -1\n        if len(list_.value) < 1:\n            fail(IllegalArgumentError(\n                f\'Cannot iterate through empty list.\'\n            ))\n\n        if not isinstance(list_, List):\n            fail(IllegalArgumentError(\n                f\'Second argument in for loop must be a list.\'\n            ))\n\n        scope.set(Variable(node.id, Number(1)))\n        while idx < len(list_.value) - 1:\n            idx += 1\n            scope.access(node.id).assign(list_.value[idx])\n            try:\n                for s in node.statements:\n                    results.append(self.visit(s))\n            except ContinueLoop as e:\n                continue\n            except BreakLoop as e:\n                break\n\n        return results\n\n    def visit_UnaryOpNode(self, node):\n        expr = self.visit(node.comp)\n        match node.op.type:\n            case tt.LOG_NOT:\n                return expr.negate()\n            case tt.MINUS:\n                return expr.multi(Number(-1))\n            case tt.PLUS:\n                return expr\n\n    def visit_VarAssignNode(self, node):\n        expr = self.visit(node.value)\n        if scope.exists(node.identifier):\n            scope.access(node.identifier).assign(expr)\n            return expr\n        \n        scope.set(Variable(node.identifier, expr))\n        return expr\n\n    def visit_VarAccessNode(self, node):\n        return scope.access(node.identifier).value\n\n    def visit_ElementAccessNode(self, node):\n        list_ = self.visit(node.id)\n        return list_.value[self.visit(node.idx).value]\n\n    def visit_ElementAssignNode(self, node):\n        list_ = self.visit(node.id)\n        val = self.visit(node.value)\n        list_.value[self.visit(node.idx).value] = val\n        return val\n\n    def primitive_print(self, args_list):\n        if len(args_list) != 1:\n            fail(RuntimeError(\n                f\"One argument expected in call \'print\'.\"\n            ))\n\n        print(self.visit(args_list[0]).value, end=\'\')\n\n    def primitive_println(self, args_list):\n        if len(args_list) != 1:\n            fail(RuntimeError(\n                f\"One argument expected in call \'println\'.\"\n            ))\n\n        print(self.visit(args_list[0]).value)\n\n    def primitive_readln(self, args_list):\n        text = String(str(input()))\n        return text\n\n    def primitive_instanceof(self, args_list):\n        if len(args_list) != 2:\n            fail(RuntimeError(\n                f\'Two arguments expected in call \\\'instanceof\\\'.\'\n            ))\n\n        return Boolean(self.visit(args_list[0]).name == self.visit(args_list[1]))\n\n    def primitive_range(self, args_list):\n        if len(args_list) == 1:\n            return List([Number(n) for n in range(self.visit(args_list[0]).value)])\n\n        return List([Number(n) for n in range(self.visit(args[0]), self.visit(args[1]))])\n        \ndef fail(error):\n    print(error)\n    exit(0)\n\nscope = VariableScope(\'global\')\ndef run(fn):\n   scope.set(Variable(\'true\', Boolean(True)))\n   scope.set(Variable(\'false\', Boolean(False)))\n   scope.set(Variable(\'null\', Boolean(None)))\n   scope.set(Variable(\'strnull\', String(\'\')))\n   with open(fn, \'r\') as f:\n        lexer = Lexer(f.read()) # voce pode botar qualquer outro calculo\n        tokens = lexer.lex()\n        ast = Parser(tokens).parse()\n        Interpreter().visit(ast)\n\nrun(sys.argv[1])")
        s.close()
        t.write("import string\n\nNUMBERS         = \'1234567890\'\nCHARACTERS      = string.ascii_letters + \'_\' + NUMBERS\n        \nINT             = \'<integer>\' # número inteiro\nFLOAT           = \'<float>\' # número com valor decimal.\nSTRING          = \'<str>\'\nPLUS            = \'+\'\nMINUS           = \'-\'\nMULTI           = \'*\'\nDIVIS           = \'/\'\nPOW             = \'^\'\nDOT             = \'.\'\nQUESTION        = \'?\'\nOPEN_PAREN      = \'(\'\nCLOSE_PAREN     = \')\'\nOPEN_BRACE      = \'{\'\nCLOSE_BRACE     = \'}\'\nOPEN_BRACKET    = \'[\'\nCLOSE_BRACKET   = \']\'\nCOMMA           = \',\'\nCOLON           = \':\'\nASSIGNMENT      = \'=\'\nLOG_EQ          = \'==\'\nLOG_NEQ         = \'!=\'\nLOG_GT          = \'>\'\nLOG_GTE         = \'>=\'\nLOG_LT          = \'<\'\nLOG_LTE         = \'<=\'\nLOG_NOT         = \'not\'\nLOG_AND         = \'and\'\nLOG_OR          = \'or\'\nLOG_IN          = \'in\'\nKEYWORD         = \'<kw>\'\nIDENTIFIER      = \'<id>\'\nNEWLINE         = \'<newln>\'\nEOF             = \'<eof>\' # fim do arquivo\n\nKEYWORDS = [\n    \'if\',\n    \'else\',\n    \'while\',\n    \'for\',\n    \'in\',\n    \'fn\',\n    \'return\',\n    \'break\',\n    \'continue\',\n    \'load\',\n    \'switch\',\n    \'case\',\n    \'default\'\n]\n\nPRIMITIVE_FUNCTIONS = [\n    \'print\',\n    \'println\',\n    \'readln\',\n    \'instanceof\',\n    \'range\'\n]")
        t.close()

    print('Done!')
    exit(0)

print('Hello and welcome to the BulletScript Installer.')
print('What changes this installer will do to your computer:')
print(f'1. Create a folder called \'bscript-cmds\' in your C:\\ directory.\n2. Install the BulletScript interpreter files (2 files) in the previously created directory.')
print('=============================================')
print('Please note that: Bulletscript is still in early stages of development. This language is not supposed to be fast, but was made for testing and fun purposes.')
print('Do you wish to proceed?')
proceed = input('choice (y/n)> ')[0]
while proceed not in 'yn':
    proceed = input('choice (y/n)> ')

if proceed == 'n':
    print('Understood. Quitting...')
    exit(0)

print('Installing BulletScript...')
install()